"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[2059],{15866:(t,e,n)=>{var r;n.d(e,{E9:()=>B,P6:()=>tt,Z_:()=>Y});var i=n(7420);const s=BigInt(0),o=BigInt(1),f=BigInt(2),a=BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h=Object.freeze({a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),P:BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),l:a,n:a,h:BigInt(8),Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960")}),c=BigInt("0x10000000000000000000000000000000000000000000000000000000000000000"),u=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"),l=(BigInt("6853475219497561581579357271197624642482790079785650197046958215289687604742"),BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235")),d=BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578"),y=BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838"),w=BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");class p{constructor(t,e,n,r){this.x=t,this.y=e,this.z=n,this.t=r}static fromAffine(t){if(!(t instanceof B))throw new TypeError("ExtendedPoint#fromAffine: expected Point");return t.equals(B.ZERO)?p.ZERO:new p(t.x,t.y,o,O(t.x*t.y))}static toAffineBatch(t){const e=function(t,e=h.P){const n=new Array(t.length),r=T(t.reduce(((t,r,i)=>r===s?t:(n[i]=t,O(t*r,e))),o),e);return t.reduceRight(((t,r,i)=>r===s?t:(n[i]=O(t*n[i],e),O(t*r,e))),r),n}(t.map((t=>t.z)));return t.map(((t,n)=>t.toAffine(e[n])))}static normalizeZ(t){return this.toAffineBatch(t).map(this.fromAffine)}equals(t){g(t);const{x:e,y:n,z:r}=this,{x:i,y:s,z:o}=t,f=O(e*o),a=O(i*r),h=O(n*o),c=O(s*r);return f===a&&h===c}negate(){return new p(O(-this.x),this.y,this.z,O(-this.t))}double(){const{x:t,y:e,z:n}=this,{a:r}=h,i=O(t*t),s=O(e*e),o=O(f*O(n*n)),a=O(r*i),c=t+e,u=O(O(c*c)-i-s),l=a+s,d=l-o,y=a-s,w=O(u*d),g=O(l*y),b=O(u*y),x=O(d*l);return new p(w,g,x,b)}add(t){g(t);const{x:e,y:n,z:r,t:i}=this,{x:o,y:a,z:h,t:c}=t,u=O((n-e)*(a+o)),l=O((n+e)*(a-o)),d=O(l-u);if(d===s)return this.double();const y=O(r*f*c),w=O(i*f*h),b=w+y,x=l+u,m=w-y,E=O(b*d),B=O(x*m),A=O(b*m),v=O(d*x);return new p(E,B,v,A)}subtract(t){return this.add(t.negate())}precomputeWindow(t){const e=1+256/t,n=[];let r=this,i=r;for(let s=0;s<e;s++){i=r,n.push(i);for(let e=1;e<2**(t-1);e++)i=i.add(r),n.push(i);r=i.double()}return n}wNAF(t,e){!e&&this.equals(p.BASE)&&(e=B.BASE);const n=e&&e._WINDOW_SIZE||1;if(256%n)throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");let r=e&&E.get(e);r||(r=this.precomputeWindow(n),e&&1!==n&&(r=p.normalizeZ(r),E.set(e,r)));let i=p.ZERO,s=p.ZERO;const f=1+256/n,a=2**(n-1),h=BigInt(2**n-1),c=2**n,u=BigInt(n);for(let e=0;e<f;e++){const n=e*a;let f=Number(t&h);if(t>>=u,f>a&&(f-=c,t+=o),0===f){let t=r[n];e%2&&(t=t.negate()),s=s.add(t)}else{let t=r[n+Math.abs(f)-1];f<0&&(t=t.negate()),i=i.add(t)}}return p.normalizeZ([i,s])[0]}multiply(t,e){return this.wNAF(_(t,h.l),e)}multiplyUnsafe(t){let e=_(t,h.l,!1);const n=p.BASE,r=p.ZERO;if(e===s)return r;if(this.equals(r)||e===o)return this;if(this.equals(n))return this.wNAF(e);let i=r,f=this;for(;e>s;)e&o&&(i=i.add(f)),f=f.double(),e>>=o;return i}isSmallOrder(){return this.multiplyUnsafe(h.h).equals(p.ZERO)}isTorsionFree(){return this.multiplyUnsafe(h.l).equals(p.ZERO)}toAffine(t=T(this.z)){const{x:e,y:n,z:r}=this,i=O(e*t),s=O(n*t);if(O(r*t)!==o)throw new Error("invZ was invalid");return new B(i,s)}fromRistrettoBytes(){x()}toRistrettoBytes(){x()}fromRistrettoHash(){x()}}function g(t){if(!(t instanceof p))throw new TypeError("ExtendedPoint expected")}function b(t){if(!(t instanceof m))throw new TypeError("RistrettoPoint expected")}function x(){throw new Error("Legacy method: switch to RistrettoPoint")}p.BASE=new p(h.Gx,h.Gy,o,O(h.Gx*h.Gy)),p.ZERO=new p(s,o,o,s);class m{constructor(t){this.ep=t}static calcElligatorRistrettoMap(t){const{d:e}=h,n=O(u*t*t),r=O((n+o)*y);let i=BigInt(-1);const s=O((i-e*n)*O(n+e));let{isValid:f,value:a}=z(r,s),c=O(a*t);Z(c)||(c=O(-c)),f||(a=c),f||(i=n);const d=O(i*(n-o)*w-s),g=a*a,b=O((a+a)*s),x=O(d*l),m=O(o-g),E=O(o+g);return new p(O(b*E),O(m*x),O(x*E),O(b*m))}static hashToCurve(t){const e=R((t=D(t,64)).slice(0,32)),n=this.calcElligatorRistrettoMap(e),r=R(t.slice(32,64)),i=this.calcElligatorRistrettoMap(r);return new m(n.add(i))}static fromHex(t){t=D(t,32);const{a:e,d:n}=h,r="RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint",i=R(t);if(!function(t,e){if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}(U(i),t)||Z(i))throw new Error(r);const f=O(i*i),a=O(o+e*f),c=O(o-e*f),u=O(a*a),l=O(c*c),d=O(e*n*u-l),{isValid:y,value:w}=F(O(d*l)),g=O(w*c),b=O(w*g*d);let x=O((i+i)*g);Z(x)&&(x=O(-x));const E=O(a*b),B=O(x*E);if(!y||Z(B)||E===s)throw new Error(r);return new m(new p(x,E,o,B))}toRawBytes(){let{x:t,y:e,z:n,t:r}=this.ep;const i=O(O(n+e)*O(n-e)),s=O(t*e),o=O(s*s),{value:f}=F(O(i*o)),a=O(f*i),h=O(f*s),c=O(a*h*r);let l;if(Z(r*c)){let n=O(e*u),r=O(t*u);t=n,e=r,l=O(a*d)}else l=h;Z(t*c)&&(e=O(-e));let y=O((n-e)*l);return Z(y)&&(y=O(-y)),U(y)}toHex(){return I(this.toRawBytes())}toString(){return this.toHex()}equals(t){b(t);const e=this.ep,n=t.ep,r=O(e.x*n.y)===O(e.y*n.x),i=O(e.y*n.y)===O(e.x*n.x);return r||i}add(t){return b(t),new m(this.ep.add(t.ep))}subtract(t){return b(t),new m(this.ep.subtract(t.ep))}multiply(t){return new m(this.ep.multiply(t))}multiplyUnsafe(t){return new m(this.ep.multiplyUnsafe(t))}}m.BASE=new m(p.BASE),m.ZERO=new m(p.ZERO);const E=new WeakMap;class B{constructor(t,e){this.x=t,this.y=e}_setWindowSize(t){this._WINDOW_SIZE=t,E.delete(this)}static fromHex(t,e=!0){const{d:n,P:r}=h,i=(t=D(t,32)).slice();i[31]=-129&t[31];const s=L(i);if(e&&s>=r)throw new Error("Expected 0 < hex < P");if(!e&&s>=c)throw new Error("Expected 0 < hex < 2**256");const f=O(s*s),a=O(f-o),u=O(n*f+o);let{isValid:l,value:d}=z(a,u);if(!l)throw new Error("Point.fromHex: invalid y coordinate");const y=(d&o)===o;return 0!=(128&t[31])!==y&&(d=O(-d)),new B(d,s)}static async fromPrivateKey(t){return(await M(t)).point}toRawBytes(){const t=U(this.y);return t[31]|=this.x&o?128:0,t}toHex(){return I(this.toRawBytes())}toX25519(){const{y:t}=this;return U(O((o+t)*T(o-t)))}isTorsionFree(){return p.fromAffine(this).isTorsionFree()}equals(t){return this.x===t.x&&this.y===t.y}negate(){return new B(O(-this.x),this.y)}add(t){return p.fromAffine(this).add(p.fromAffine(t)).toAffine()}subtract(t){return this.add(t.negate())}multiply(t){return p.fromAffine(this).multiply(t,this).toAffine()}}B.BASE=new B(h.Gx,h.Gy),B.ZERO=new B(s,o);class A{constructor(t,e){this.r=t,this.s=e,this.assertValidity()}static fromHex(t){const e=D(t,64),n=B.fromHex(e.slice(0,32),!1),r=L(e.slice(32,64));return new A(n,r)}assertValidity(){const{r:t,s:e}=this;if(!(t instanceof B))throw new Error("Expected Point instance");return _(e,h.l,!1),this}toRawBytes(){const t=new Uint8Array(64);return t.set(this.r.toRawBytes()),t.set(U(this.s),32),t}toHex(){return I(this.toRawBytes())}}function v(...t){if(!t.every((t=>t instanceof Uint8Array)))throw new Error("Expected Uint8Array list");if(1===t.length)return t[0];const e=t.reduce(((t,e)=>t+e.length),0),n=new Uint8Array(e);for(let e=0,r=0;e<t.length;e++){const i=t[e];n.set(i,r),r+=i.length}return n}const S=Array.from({length:256},((t,e)=>e.toString(16).padStart(2,"0")));function I(t){if(!(t instanceof Uint8Array))throw new Error("Uint8Array expected");let e="";for(let n=0;n<t.length;n++)e+=S[t[n]];return e}function P(t){if("string"!=typeof t)throw new TypeError("hexToBytes: expected string, got "+typeof t);if(t.length%2)throw new Error("hexToBytes: received invalid unpadded hex");const e=new Uint8Array(t.length/2);for(let n=0;n<e.length;n++){const r=2*n,i=t.slice(r,r+2),s=Number.parseInt(i,16);if(Number.isNaN(s)||s<0)throw new Error("Invalid byte sequence");e[n]=s}return e}function H(t){return P(t.toString(16).padStart(64,"0"))}function U(t){return H(t).reverse()}function Z(t){return(O(t)&o)===o}function L(t){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");return BigInt("0x"+I(Uint8Array.from(t).reverse()))}const k=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");function R(t){return O(L(t)&k)}function O(t,e=h.P){const n=t%e;return n>=s?n:e+n}function T(t,e=h.P){if(t===s||e<=s)throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);let n=O(t,e),r=e,i=s,f=o,a=o,c=s;for(;n!==s;){const t=r/n,e=r%n,s=i-a*t,o=f-c*t;r=n,n=e,i=a,f=c,a=s,c=o}if(r!==o)throw new Error("invert: does not exist");return O(i,e)}function C(t,e){const{P:n}=h;let r=t;for(;e-- >s;)r*=r,r%=n;return r}function N(t){const{P:e}=h,n=BigInt(5),r=BigInt(10),i=BigInt(20),s=BigInt(40),a=BigInt(80),c=t*t%e*t%e,u=C(c,f)*c%e,l=C(u,o)*t%e,d=C(l,n)*l%e,y=C(d,r)*d%e,w=C(y,i)*y%e,p=C(w,s)*w%e,g=C(p,a)*p%e,b=C(g,a)*p%e,x=C(b,r)*d%e;return{pow_p_5_8:C(x,f)*t%e,b2:c}}function z(t,e){const n=O(e*e*e),r=O(n*n*e);let i=O(t*n*N(t*r).pow_p_5_8);const s=O(e*i*i),o=i,f=O(i*u),a=s===t,h=s===O(-t),c=s===O(-t*u);return a&&(i=o),(h||c)&&(i=f),Z(i)&&(i=O(-i)),{isValid:a||h,value:i}}function F(t){return z(o,t)}function G(t){return O(L(t),h.l)}function D(t,e){const n=t instanceof Uint8Array?Uint8Array.from(t):P(t);if("number"==typeof e&&n.length!==e)throw new Error(`Expected ${e} bytes`);return n}function _(t,e,n=!0){if(!e)throw new TypeError("Specify max value");if("number"==typeof t&&Number.isSafeInteger(t)&&(t=BigInt(t)),"bigint"==typeof t&&t<e)if(n){if(s<t)return t}else if(s<=t)return t;throw new TypeError("Expected valid scalar: 0 < scalar < max")}function $(t){return t[0]&=248,t[31]&=127,t[31]|=64,t}function W(t){if(32!==(t="bigint"==typeof t||"number"==typeof t?H(_(t,c)):D(t)).length)throw new Error("Expected 32 bytes");return t}function q(t){const e=$(t.slice(0,32)),n=t.slice(32,64),r=G(e),i=B.BASE.multiply(r),s=i.toRawBytes();return{head:e,prefix:n,scalar:r,point:i,pointBytes:s}}let V;function K(...t){if("function"!=typeof V)throw new Error("utils.sha512Sync must be set to use sync methods");return V(...t)}async function M(t){return q(await tt.sha512(W(t)))}function j(t){return q(K(W(t)))}function X(t,e,n){e=D(e),n instanceof B||(n=B.fromHex(n,!1));const{r,s:i}=t instanceof A?t.assertValidity():A.fromHex(t);return{r,s:i,SB:p.BASE.multiplyUnsafe(i),pub:n,msg:e}}function J(t,e,n,r){const i=G(r),s=p.fromAffine(t).multiplyUnsafe(i);return p.fromAffine(e).add(s).subtract(n).multiplyUnsafe(h.h).equals(p.ZERO)}const Y={getExtendedPublicKey:j,getPublicKey:function(t){return j(t).pointBytes},sign:function(t,e){t=D(t);const{prefix:n,scalar:r,pointBytes:i}=j(e),s=G(K(n,t)),o=B.BASE.multiply(s),f=O(s+G(K(o.toRawBytes(),i,t))*r,h.l);return new A(o,f).toRawBytes()},verify:function(t,e,n){const{r,SB:i,msg:s,pub:o}=X(t,e,n),f=K(r.toRawBytes(),o.toRawBytes(),s);return J(o,r,i,f)}};B.BASE._setWindowSize(8);const Q={node:r||(r=n.t(i,2)),web:"object"==typeof self&&"crypto"in self?self.crypto:void 0},tt={bytesToHex:I,hexToBytes:P,concatBytes:v,getExtendedPublicKey:M,mod:O,invert:T,TORSION_SUBGROUP:["0100000000000000000000000000000000000000000000000000000000000000","c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a","0000000000000000000000000000000000000000000000000000000000000080","26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05","ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f","26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85","0000000000000000000000000000000000000000000000000000000000000000","c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"],hashToPrivateScalar:t=>{if((t=D(t)).length<40||t.length>1024)throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");return O(L(t),h.l-o)+o},randomBytes:(t=32)=>{if(Q.web)return Q.web.getRandomValues(new Uint8Array(t));if(Q.node){const{randomBytes:e}=Q.node;return new Uint8Array(e(t).buffer)}throw new Error("The environment doesn't have randomBytes function")},randomPrivateKey:()=>tt.randomBytes(32),sha512:async(...t)=>{const e=v(...t);if(Q.web){const t=await Q.web.subtle.digest("SHA-512",e.buffer);return new Uint8Array(t)}if(Q.node)return Uint8Array.from(Q.node.createHash("sha512").update(e).digest());throw new Error("The environment doesn't have sha512 function")},precompute(t=8,e=B.BASE){const n=e.equals(B.BASE)?e:new B(e.x,e.y);return n._setWindowSize(t),n.multiply(f),n},sha512Sync:void 0};Object.defineProperties(tt,{sha512Sync:{configurable:!1,get:()=>V,set(t){V||(V=t)}}})},93527:(t,e,n)=>{function r(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`Wrong positive integer: ${t}`)}function i(t,...e){if(!(t instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(e.length>0&&!e.includes(t.length))throw new TypeError(`Expected Uint8Array of length ${e}, not of length=${t.length}`)}n.d(e,{ZP:()=>o});const s={number:r,bool:function(t){if("boolean"!=typeof t)throw new Error(`Expected boolean, not ${t}`)},bytes:i,hash:function(t){if("function"!=typeof t||"function"!=typeof t.create)throw new Error("Hash should be wrapped by utils.wrapConstructor");r(t.outputLen),r(t.blockLen)},exists:function(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")},output:function(t,e){i(t);const n=e.outputLen;if(t.length<n)throw new Error(`digestInto() expects output buffer of length at least ${n}`)}},o=s},3313:(t,e,n)=>{n.d(e,{N:()=>s});var r=n(93527),i=n(93811);class s extends i.kb{constructor(t,e,n,r){super(),this.blockLen=t,this.outputLen=e,this.padOffset=n,this.isLE=r,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=(0,i.GL)(this.buffer)}update(t){r.ZP.exists(this);const{view:e,buffer:n,blockLen:s}=this,o=(t=(0,i.O0)(t)).length;for(let r=0;r<o;){const f=Math.min(s-this.pos,o-r);if(f!==s)n.set(t.subarray(r,r+f),this.pos),this.pos+=f,r+=f,this.pos===s&&(this.process(e,0),this.pos=0);else{const e=(0,i.GL)(t);for(;s<=o-r;r+=s)this.process(e,r)}}return this.length+=t.length,this.roundClean(),this}digestInto(t){r.ZP.exists(this),r.ZP.output(t,this),this.finished=!0;const{buffer:e,view:n,blockLen:s,isLE:o}=this;let{pos:f}=this;e[f++]=128,this.buffer.subarray(f).fill(0),this.padOffset>s-f&&(this.process(n,0),f=0);for(let t=f;t<s;t++)e[t]=0;!function(t,e,n,r){if("function"==typeof t.setBigUint64)return t.setBigUint64(e,n,r);const i=BigInt(32),s=BigInt(4294967295),o=Number(n>>i&s),f=Number(n&s),a=r?4:0,h=r?0:4;t.setUint32(e+a,o,r),t.setUint32(e+h,f,r)}(n,s-8,BigInt(8*this.length),o),this.process(n,0);const a=(0,i.GL)(t);this.get().forEach(((t,e)=>a.setUint32(4*e,t,o)))}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const n=t.slice(0,e);return this.destroy(),n}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:n,length:r,finished:i,destroyed:s,pos:o}=this;return t.length=r,t.pos=o,t.finished=i,t.destroyed=s,r%e&&t.buffer.set(n),t}}},91881:(t,e,n)=>{n.d(e,{ZP:()=>o});const r=BigInt(2**32-1),i=BigInt(32);function s(t,e=!1){return e?{h:Number(t&r),l:Number(t>>i&r)}:{h:0|Number(t>>i&r),l:0|Number(t&r)}}const o={fromBig:s,split:function(t,e=!1){let n=new Uint32Array(t.length),r=new Uint32Array(t.length);for(let i=0;i<t.length;i++){const{h:o,l:f}=s(t[i],e);[n[i],r[i]]=[o,f]}return[n,r]},toBig:(t,e)=>BigInt(t>>>0)<<i|BigInt(e>>>0),shrSH:(t,e,n)=>t>>>n,shrSL:(t,e,n)=>t<<32-n|e>>>n,rotrSH:(t,e,n)=>t>>>n|e<<32-n,rotrSL:(t,e,n)=>t<<32-n|e>>>n,rotrBH:(t,e,n)=>t<<64-n|e>>>n-32,rotrBL:(t,e,n)=>t>>>n-32|e<<64-n,rotr32H:(t,e)=>e,rotr32L:(t,e)=>t,rotlSH:(t,e,n)=>t<<n|e>>>32-n,rotlSL:(t,e,n)=>e<<n|t>>>32-n,rotlBH:(t,e,n)=>e<<n-32|t>>>64-n,rotlBL:(t,e,n)=>t<<n-32|e>>>64-n,add:function(t,e,n,r){const i=(e>>>0)+(r>>>0);return{h:t+n+(i/2**32|0)|0,l:0|i}},add3L:(t,e,n)=>(t>>>0)+(e>>>0)+(n>>>0),add3H:(t,e,n,r)=>e+n+r+(t/2**32|0)|0,add4L:(t,e,n,r)=>(t>>>0)+(e>>>0)+(n>>>0)+(r>>>0),add4H:(t,e,n,r,i)=>e+n+r+i+(t/2**32|0)|0,add5H:(t,e,n,r,i,s)=>e+n+r+i+s+(t/2**32|0)|0,add5L:(t,e,n,r,i)=>(t>>>0)+(e>>>0)+(n>>>0)+(r>>>0)+(i>>>0)}},9905:(t,e,n)=>{n.d(e,{b:()=>o});var r=n(93527),i=n(93811);class s extends i.kb{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,r.ZP.hash(t);const n=(0,i.O0)(e);if(this.iHash=t.create(),"function"!=typeof this.iHash.update)throw new TypeError("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,o=new Uint8Array(s);o.set(n.length>s?t.create().update(n).digest():n);for(let t=0;t<o.length;t++)o[t]^=54;this.iHash.update(o),this.oHash=t.create();for(let t=0;t<o.length;t++)o[t]^=106;this.oHash.update(o),o.fill(0)}update(t){return r.ZP.exists(this),this.iHash.update(t),this}digestInto(t){r.ZP.exists(this),r.ZP.bytes(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:n,finished:r,destroyed:i,blockLen:s,outputLen:o}=this;return t.finished=r,t.destroyed=i,t.blockLen=s,t.outputLen=o,t.oHash=e._cloneInto(t.oHash),t.iHash=n._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const o=(t,e,n)=>new s(t,e).update(n).digest();o.create=(t,e)=>new s(t,e)},17748:(t,e,n)=>{n.d(e,{J:()=>c});var r=n(3313),i=n(93811);const s=(t,e,n)=>t&e^t&n^e&n,o=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),f=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),a=new Uint32Array(64);class h extends r.N{constructor(){super(64,32,8,!1),this.A=0|f[0],this.B=0|f[1],this.C=0|f[2],this.D=0|f[3],this.E=0|f[4],this.F=0|f[5],this.G=0|f[6],this.H=0|f[7]}get(){const{A:t,B:e,C:n,D:r,E:i,F:s,G:o,H:f}=this;return[t,e,n,r,i,s,o,f]}set(t,e,n,r,i,s,o,f){this.A=0|t,this.B=0|e,this.C=0|n,this.D=0|r,this.E=0|i,this.F=0|s,this.G=0|o,this.H=0|f}process(t,e){for(let n=0;n<16;n++,e+=4)a[n]=t.getUint32(e,!1);for(let t=16;t<64;t++){const e=a[t-15],n=a[t-2],r=(0,i.np)(e,7)^(0,i.np)(e,18)^e>>>3,s=(0,i.np)(n,17)^(0,i.np)(n,19)^n>>>10;a[t]=s+a[t-7]+r+a[t-16]|0}let{A:n,B:r,C:f,D:h,E:c,F:u,G:l,H:d}=this;for(let t=0;t<64;t++){const e=d+((0,i.np)(c,6)^(0,i.np)(c,11)^(0,i.np)(c,25))+((y=c)&u^~y&l)+o[t]+a[t]|0,w=((0,i.np)(n,2)^(0,i.np)(n,13)^(0,i.np)(n,22))+s(n,r,f)|0;d=l,l=u,u=c,c=h+e|0,h=f,f=r,r=n,n=e+w|0}var y;n=n+this.A|0,r=r+this.B|0,f=f+this.C|0,h=h+this.D|0,c=c+this.E|0,u=u+this.F|0,l=l+this.G|0,d=d+this.H|0,this.set(n,r,f,h,c,u,l,d)}roundClean(){a.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const c=(0,i.hE)((()=>new h))},85609:(t,e,n)=>{n.d(e,{fr:()=>E});var r=n(93527),i=n(91881),s=n(93811);const[o,f,a]=[[],[],[]],h=BigInt(0),c=BigInt(1),u=BigInt(2),l=BigInt(7),d=BigInt(256),y=BigInt(113);for(let t=0,e=c,n=1,r=0;t<24;t++){[n,r]=[r,(2*n+3*r)%5],o.push(2*(5*r+n)),f.push((t+1)*(t+2)/2%64);let i=h;for(let t=0;t<7;t++)e=(e<<c^(e>>l)*y)%d,e&u&&(i^=c<<(c<<BigInt(t))-c);a.push(i)}const[w,p]=i.ZP.split(a,!0),g=(t,e,n)=>n>32?i.ZP.rotlBH(t,e,n):i.ZP.rotlSH(t,e,n),b=(t,e,n)=>n>32?i.ZP.rotlBL(t,e,n):i.ZP.rotlSL(t,e,n);class x extends s.kb{constructor(t,e,n,i=!1,o=24){if(super(),this.blockLen=t,this.suffix=e,this.outputLen=n,this.enableXOF=i,this.rounds=o,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,r.ZP.number(n),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=(0,s.Jq)(this.state)}keccak(){!function(t,e=24){const n=new Uint32Array(10);for(let r=24-e;r<24;r++){for(let e=0;e<10;e++)n[e]=t[e]^t[e+10]^t[e+20]^t[e+30]^t[e+40];for(let e=0;e<10;e+=2){const r=(e+8)%10,i=(e+2)%10,s=n[i],o=n[i+1],f=g(s,o,1)^n[r],a=b(s,o,1)^n[r+1];for(let n=0;n<50;n+=10)t[e+n]^=f,t[e+n+1]^=a}let e=t[2],i=t[3];for(let n=0;n<24;n++){const r=f[n],s=g(e,i,r),a=b(e,i,r),h=o[n];e=t[h],i=t[h+1],t[h]=s,t[h+1]=a}for(let e=0;e<50;e+=10){for(let r=0;r<10;r++)n[r]=t[e+r];for(let r=0;r<10;r++)t[e+r]^=~n[(r+2)%10]&n[(r+4)%10]}t[0]^=w[r],t[1]^=p[r]}n.fill(0)}(this.state32,this.rounds),this.posOut=0,this.pos=0}update(t){r.ZP.exists(this);const{blockLen:e,state:n}=this,i=(t=(0,s.O0)(t)).length;for(let r=0;r<i;){const s=Math.min(e-this.pos,i-r);for(let e=0;e<s;e++)n[this.pos++]^=t[r++];this.pos===e&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:t,suffix:e,pos:n,blockLen:r}=this;t[n]^=e,0!=(128&e)&&n===r-1&&this.keccak(),t[r-1]^=128,this.keccak()}writeInto(t){r.ZP.exists(this,!1),r.ZP.bytes(t),this.finish();const e=this.state,{blockLen:n}=this;for(let r=0,i=t.length;r<i;){this.posOut>=n&&this.keccak();const s=Math.min(n-this.posOut,i-r);t.set(e.subarray(this.posOut,this.posOut+s),r),this.posOut+=s,r+=s}return t}xofInto(t){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(t)}xof(t){return r.ZP.number(t),this.xofInto(new Uint8Array(t))}digestInto(t){if(r.ZP.output(t,this),this.finished)throw new Error("digest() was already called");return this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(t){const{blockLen:e,suffix:n,outputLen:r,rounds:i,enableXOF:s}=this;return t||(t=new x(e,n,r,s,i)),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=i,t.suffix=n,t.outputLen=r,t.enableXOF=s,t.destroyed=this.destroyed,t}}const m=(t,e,n)=>(0,s.hE)((()=>new x(e,t,n))),E=(m(6,144,28),m(6,136,32),m(6,104,48),m(6,72,64),m(1,144,28),m(1,136,32)),B=(m(1,104,48),m(1,72,64),(t,e,n)=>(0,s.K$)(((r={})=>new x(e,t,void 0===r.dkLen?n:r.dkLen,!0))));B(31,168,16),B(31,136,32)},74736:(t,e,n)=>{n.d(e,{o:()=>d});var r=n(3313),i=n(91881),s=n(93811);const[o,f]=i.ZP.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map((t=>BigInt(t)))),a=new Uint32Array(80),h=new Uint32Array(80);class c extends r.N{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:t,Al:e,Bh:n,Bl:r,Ch:i,Cl:s,Dh:o,Dl:f,Eh:a,El:h,Fh:c,Fl:u,Gh:l,Gl:d,Hh:y,Hl:w}=this;return[t,e,n,r,i,s,o,f,a,h,c,u,l,d,y,w]}set(t,e,n,r,i,s,o,f,a,h,c,u,l,d,y,w){this.Ah=0|t,this.Al=0|e,this.Bh=0|n,this.Bl=0|r,this.Ch=0|i,this.Cl=0|s,this.Dh=0|o,this.Dl=0|f,this.Eh=0|a,this.El=0|h,this.Fh=0|c,this.Fl=0|u,this.Gh=0|l,this.Gl=0|d,this.Hh=0|y,this.Hl=0|w}process(t,e){for(let n=0;n<16;n++,e+=4)a[n]=t.getUint32(e),h[n]=t.getUint32(e+=4);for(let t=16;t<80;t++){const e=0|a[t-15],n=0|h[t-15],r=i.ZP.rotrSH(e,n,1)^i.ZP.rotrSH(e,n,8)^i.ZP.shrSH(e,n,7),s=i.ZP.rotrSL(e,n,1)^i.ZP.rotrSL(e,n,8)^i.ZP.shrSL(e,n,7),o=0|a[t-2],f=0|h[t-2],c=i.ZP.rotrSH(o,f,19)^i.ZP.rotrBH(o,f,61)^i.ZP.shrSH(o,f,6),u=i.ZP.rotrSL(o,f,19)^i.ZP.rotrBL(o,f,61)^i.ZP.shrSL(o,f,6),l=i.ZP.add4L(s,u,h[t-7],h[t-16]),d=i.ZP.add4H(l,r,c,a[t-7],a[t-16]);a[t]=0|d,h[t]=0|l}let{Ah:n,Al:r,Bh:s,Bl:c,Ch:u,Cl:l,Dh:d,Dl:y,Eh:w,El:p,Fh:g,Fl:b,Gh:x,Gl:m,Hh:E,Hl:B}=this;for(let t=0;t<80;t++){const e=i.ZP.rotrSH(w,p,14)^i.ZP.rotrSH(w,p,18)^i.ZP.rotrBH(w,p,41),A=i.ZP.rotrSL(w,p,14)^i.ZP.rotrSL(w,p,18)^i.ZP.rotrBL(w,p,41),v=w&g^~w&x,S=p&b^~p&m,I=i.ZP.add5L(B,A,S,f[t],h[t]),P=i.ZP.add5H(I,E,e,v,o[t],a[t]),H=0|I,U=i.ZP.rotrSH(n,r,28)^i.ZP.rotrBH(n,r,34)^i.ZP.rotrBH(n,r,39),Z=i.ZP.rotrSL(n,r,28)^i.ZP.rotrBL(n,r,34)^i.ZP.rotrBL(n,r,39),L=n&s^n&u^s&u,k=r&c^r&l^c&l;E=0|x,B=0|m,x=0|g,m=0|b,g=0|w,b=0|p,({h:w,l:p}=i.ZP.add(0|d,0|y,0|P,0|H)),d=0|u,y=0|l,u=0|s,l=0|c,s=0|n,c=0|r;const R=i.ZP.add3L(H,Z,k);n=i.ZP.add3H(R,P,U,L),r=0|R}({h:n,l:r}=i.ZP.add(0|this.Ah,0|this.Al,0|n,0|r)),({h:s,l:c}=i.ZP.add(0|this.Bh,0|this.Bl,0|s,0|c)),({h:u,l}=i.ZP.add(0|this.Ch,0|this.Cl,0|u,0|l)),({h:d,l:y}=i.ZP.add(0|this.Dh,0|this.Dl,0|d,0|y)),({h:w,l:p}=i.ZP.add(0|this.Eh,0|this.El,0|w,0|p)),({h:g,l:b}=i.ZP.add(0|this.Fh,0|this.Fl,0|g,0|b)),({h:x,l:m}=i.ZP.add(0|this.Gh,0|this.Gl,0|x,0|m)),({h:E,l:B}=i.ZP.add(0|this.Hh,0|this.Hl,0|E,0|B)),this.set(n,r,s,c,u,l,d,y,w,p,g,b,x,m,E,B)}roundClean(){a.fill(0),h.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}class u extends c{constructor(){super(),this.Ah=573645204,this.Al=-64227540,this.Bh=-1621794909,this.Bl=-934517566,this.Ch=596883563,this.Cl=1867755857,this.Dh=-1774684391,this.Dl=1497426621,this.Eh=-1775747358,this.El=-1467023389,this.Fh=-1101128155,this.Fl=1401305490,this.Gh=721525244,this.Gl=746961066,this.Hh=246885852,this.Hl=-2117784414,this.outputLen=32}}class l extends c{constructor(){super(),this.Ah=-876896931,this.Al=-1056596264,this.Bh=1654270250,this.Bl=914150663,this.Ch=-1856437926,this.Cl=812702999,this.Dh=355462360,this.Dl=-150054599,this.Eh=1731405415,this.El=-4191439,this.Fh=-1900787065,this.Fl=1750603025,this.Gh=-619958771,this.Gl=1694076839,this.Hh=1203062813,this.Hl=-1090891868,this.outputLen=48}}const d=(0,s.hE)((()=>new c));(0,s.hE)((()=>new u)),(0,s.hE)((()=>new l))},93811:(t,e,n)=>{n.d(e,{kb:()=>f,GL:()=>i,np:()=>s,O0:()=>o,Jq:()=>r,hE:()=>a,K$:()=>h});"object"==typeof self&&"crypto"in self&&self.crypto;const r=t=>new Uint32Array(t.buffer,t.byteOffset,Math.floor(t.byteLength/4)),i=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),s=(t,e)=>t<<32-e|t>>>e;if(!(68===new Uint8Array(new Uint32Array([287454020]).buffer)[0]))throw new Error("Non little-endian hardware is not supported");Array.from({length:256},((t,e)=>e.toString(16).padStart(2,"0")));function o(t){if("string"==typeof t&&(t=function(t){if("string"!=typeof t)throw new TypeError("utf8ToBytes expected string, got "+typeof t);return(new TextEncoder).encode(t)}(t)),!(t instanceof Uint8Array))throw new TypeError(`Expected input type is Uint8Array (got ${typeof t})`);return t}class f{clone(){return this._cloneInto()}}function a(t){const e=e=>t().update(o(e)).digest(),n=t();return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=()=>t(),e}function h(t){const e=(e,n)=>t(n).update(o(e)).digest(),n=t({});return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=e=>t(e),e}},27760:(t,e,n)=>{var r;n.d(e,{$3:()=>K,P6:()=>nt,kS:()=>Q});var i=n(95856);const s=BigInt(0),o=BigInt(1),f=BigInt(2),a=BigInt(3),h=BigInt(8),c=Object.freeze({a:s,b:BigInt(7),P:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:o,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")});function u(t){const{a:e,b:n}=c,r=k(t*t),i=k(r*t);return k(i+e*t+n)}const l=c.a===s;class d extends Error{constructor(t){super(t)}}class y{constructor(t,e,n){this.x=t,this.y=e,this.z=n}static fromAffine(t){if(!(t instanceof p))throw new TypeError("JacobianPoint#fromAffine: expected Point");return new y(t.x,t.y,o)}static toAffineBatch(t){const e=function(t,e=c.P){const n=new Array(t.length),r=O(t.reduce(((t,r,i)=>r===s?t:(n[i]=t,k(t*r,e))),o),e);return t.reduceRight(((t,r,i)=>r===s?t:(n[i]=k(t*n[i],e),k(t*r,e))),r),n}(t.map((t=>t.z)));return t.map(((t,n)=>t.toAffine(e[n])))}static normalizeZ(t){return y.toAffineBatch(t).map(y.fromAffine)}equals(t){if(!(t instanceof y))throw new TypeError("JacobianPoint expected");const{x:e,y:n,z:r}=this,{x:i,y:s,z:o}=t,f=k(r*r),a=k(o*o),h=k(e*a),c=k(i*f),u=k(k(n*o)*a),l=k(k(s*r)*f);return h===c&&u===l}negate(){return new y(this.x,k(-this.y),this.z)}double(){const{x:t,y:e,z:n}=this,r=k(t*t),i=k(e*e),s=k(i*i),o=t+i,c=k(f*(k(o*o)-r-s)),u=k(a*r),l=k(u*u),d=k(l-f*c),w=k(u*(c-d)-h*s),p=k(f*e*n);return new y(d,w,p)}add(t){if(!(t instanceof y))throw new TypeError("JacobianPoint expected");const{x:e,y:n,z:r}=this,{x:i,y:o,z:a}=t;if(i===s||o===s)return this;if(e===s||n===s)return t;const h=k(r*r),c=k(a*a),u=k(e*c),l=k(i*h),d=k(k(n*a)*c),w=k(k(o*r)*h),p=k(l-u),g=k(w-d);if(p===s)return g===s?this.double():y.ZERO;const b=k(p*p),x=k(p*b),m=k(u*b),E=k(g*g-x-f*m),B=k(g*(m-E)-d*x),A=k(r*a*p);return new y(E,B,A)}subtract(t){return this.add(t.negate())}multiplyUnsafe(t){const e=y.ZERO;if("bigint"==typeof t&&t===s)return e;let n=L(t);if(n===o)return this;if(!l){let t=e,r=this;for(;n>s;)n&o&&(t=t.add(r)),r=r.double(),n>>=o;return t}let{k1neg:r,k1:i,k2neg:f,k2:a}=N(n),h=e,u=e,d=this;for(;i>s||a>s;)i&o&&(h=h.add(d)),a&o&&(u=u.add(d)),d=d.double(),i>>=o,a>>=o;return r&&(h=h.negate()),f&&(u=u.negate()),u=new y(k(u.x*c.beta),u.y,u.z),h.add(u)}precomputeWindow(t){const e=l?128/t+1:256/t+1,n=[];let r=this,i=r;for(let s=0;s<e;s++){i=r,n.push(i);for(let e=1;e<2**(t-1);e++)i=i.add(r),n.push(i);r=i.double()}return n}wNAF(t,e){!e&&this.equals(y.BASE)&&(e=p.BASE);const n=e&&e._WINDOW_SIZE||1;if(256%n)throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");let r=e&&w.get(e);r||(r=this.precomputeWindow(n),e&&1!==n&&(r=y.normalizeZ(r),w.set(e,r)));let i=y.ZERO,s=y.ZERO;const f=1+(l?128/n:256/n),a=2**(n-1),h=BigInt(2**n-1),c=2**n,u=BigInt(n);for(let e=0;e<f;e++){const n=e*a;let f=Number(t&h);if(t>>=u,f>a&&(f-=c,t+=o),0===f){let t=r[n];e%2&&(t=t.negate()),s=s.add(t)}else{let t=r[n+Math.abs(f)-1];f<0&&(t=t.negate()),i=i.add(t)}}return{p:i,f:s}}multiply(t,e){let n,r,i=L(t);if(l){const{k1neg:t,k1:s,k2neg:o,k2:f}=N(i);let{p:a,f:h}=this.wNAF(s,e),{p:u,f:l}=this.wNAF(f,e);t&&(a=a.negate()),o&&(u=u.negate()),u=new y(k(u.x*c.beta),u.y,u.z),n=a.add(u),r=h.add(l)}else{const{p:t,f:s}=this.wNAF(i,e);n=t,r=s}return y.normalizeZ([n,r])[0]}toAffine(t=O(this.z)){const{x:e,y:n,z:r}=this,i=t,s=k(i*i),f=k(s*i),a=k(e*s),h=k(n*f);if(k(r*i)!==o)throw new Error("invZ was invalid");return new p(a,h)}}y.BASE=new y(c.Gx,c.Gy,o),y.ZERO=new y(s,o,s);const w=new WeakMap;class p{constructor(t,e){this.x=t,this.y=e}_setWindowSize(t){this._WINDOW_SIZE=t,w.delete(this)}hasEvenY(){return this.y%f===s}static fromCompressedHex(t){const e=32===t.length,n=U(e?t:t.subarray(1));if(!$(n))throw new Error("Point is not on curve");let r=function(t){const{P:e}=c,n=BigInt(6),r=BigInt(11),i=BigInt(22),s=BigInt(23),o=BigInt(44),h=BigInt(88),u=t*t*t%e,l=u*u*t%e,d=R(l,a)*l%e,y=R(d,a)*l%e,w=R(y,f)*u%e,p=R(w,r)*w%e,g=R(p,i)*p%e,b=R(g,o)*g%e,x=R(b,h)*b%e,m=R(x,o)*g%e,E=R(m,a)*l%e,B=R(E,s)*p%e,A=R(B,n)*u%e;return R(A,f)}(u(n));const i=(r&o)===o;if(e)i&&(r=k(-r));else{1==(1&t[0])!==i&&(r=k(-r))}const s=new p(n,r);return s.assertValidity(),s}static fromUncompressedHex(t){const e=U(t.subarray(1,33)),n=U(t.subarray(33,65)),r=new p(e,n);return r.assertValidity(),r}static fromHex(t){const e=Z(t),n=e.length,r=e[0];if(32===n||33===n&&(2===r||3===r))return this.fromCompressedHex(e);if(65===n&&4===r)return this.fromUncompressedHex(e);throw new Error(`Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${n}`)}static fromPrivateKey(t){return p.BASE.multiply(q(t))}static fromSignature(t,e,n){const r=z(t=Z(t)),{r:i,s}=V(e);if(0!==n&&1!==n)throw new Error("Cannot recover signature: invalid recovery bit");const o=1&n?"03":"02",f=p.fromHex(o+v(i)),{n:a}=c,h=O(i,a),u=k(-r*h,a),l=k(s*h,a),d=p.BASE.multiplyAndAddUnsafe(f,u,l);if(!d)throw new Error("Cannot recover signature: point at infinify");return d.assertValidity(),d}toRawBytes(t=!1){return H(this.toHex(t))}toHex(t=!1){const e=v(this.x);if(t){return`${this.hasEvenY()?"02":"03"}${e}`}return`04${e}${v(this.y)}`}toHexX(){return this.toHex(!0).slice(2)}toRawX(){return this.toRawBytes(!0).slice(1)}assertValidity(){const t="Point is not on elliptic curve",{x:e,y:n}=this;if(!$(e)||!$(n))throw new Error(t);const r=k(n*n);if(k(r-u(e))!==s)throw new Error(t)}equals(t){return this.x===t.x&&this.y===t.y}negate(){return new p(this.x,k(-this.y))}double(){return y.fromAffine(this).double().toAffine()}add(t){return y.fromAffine(this).add(y.fromAffine(t)).toAffine()}subtract(t){return this.add(t.negate())}multiply(t){return y.fromAffine(this).multiply(t,this).toAffine()}multiplyAndAddUnsafe(t,e,n){const r=y.fromAffine(this),i=e===s||e===o||this!==p.BASE?r.multiplyUnsafe(e):r.multiply(e),f=y.fromAffine(t).multiplyUnsafe(n),a=i.add(f);return a.equals(y.ZERO)?void 0:a.toAffine()}}function g(t){return Number.parseInt(t[0],16)>=8?"00"+t:t}function b(t){if(t.length<2||2!==t[0])throw new Error(`Invalid signature integer tag: ${B(t)}`);const e=t[1],n=t.subarray(2,e+2);if(!e||n.length!==e)throw new Error("Invalid signature integer: wrong length");if(0===n[0]&&n[1]<=127)throw new Error("Invalid signature integer: trailing length");return{data:U(n),left:t.subarray(e+2)}}p.BASE=new p(c.Gx,c.Gy),p.ZERO=new p(s,s);class x{constructor(t,e){this.r=t,this.s=e,this.assertValidity()}static fromCompact(t){const e=t instanceof Uint8Array,n="Signature.fromCompact";if("string"!=typeof t&&!e)throw new TypeError(`${n}: Expected string or Uint8Array`);const r=e?B(t):t;if(128!==r.length)throw new Error(`${n}: Expected 64-byte hex`);return new x(P(r.slice(0,64)),P(r.slice(64,128)))}static fromDER(t){const e=t instanceof Uint8Array;if("string"!=typeof t&&!e)throw new TypeError("Signature.fromDER: Expected string or Uint8Array");const{r:n,s:r}=function(t){if(t.length<2||48!=t[0])throw new Error(`Invalid signature tag: ${B(t)}`);if(t[1]!==t.length-2)throw new Error("Invalid signature: incorrect length");const{data:e,left:n}=b(t.subarray(2)),{data:r,left:i}=b(n);if(i.length)throw new Error(`Invalid signature: left bytes after parsing: ${B(i)}`);return{r:e,s:r}}(e?t:H(t));return new x(n,r)}static fromHex(t){return this.fromDER(t)}assertValidity(){const{r:t,s:e}=this;if(!_(t))throw new Error("Invalid Signature: r must be 0 < r < n");if(!_(e))throw new Error("Invalid Signature: s must be 0 < s < n")}hasHighS(){const t=c.n>>o;return this.s>t}normalizeS(){return this.hasHighS()?new x(this.r,c.n-this.s):this}toDERRawBytes(t=!1){return H(this.toDERHex(t))}toDERHex(t=!1){const e=g(I(this.s));if(t)return e;const n=g(I(this.r)),r=I(n.length/2),i=I(e.length/2);return`30${I(n.length/2+e.length/2+4)}02${r}${n}02${i}${e}`}toRawBytes(){return this.toDERRawBytes()}toHex(){return this.toDERHex()}toCompactRawBytes(){return H(this.toCompactHex())}toCompactHex(){return v(this.r)+v(this.s)}}function m(...t){if(!t.every((t=>t instanceof Uint8Array)))throw new Error("Uint8Array list expected");if(1===t.length)return t[0];const e=t.reduce(((t,e)=>t+e.length),0),n=new Uint8Array(e);for(let e=0,r=0;e<t.length;e++){const i=t[e];n.set(i,r),r+=i.length}return n}const E=Array.from({length:256},((t,e)=>e.toString(16).padStart(2,"0")));function B(t){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");let e="";for(let n=0;n<t.length;n++)e+=E[t[n]];return e}const A=BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");function v(t){if("bigint"!=typeof t)throw new Error("Expected bigint");if(!(s<=t&&t<A))throw new Error("Expected number < 2^256");return t.toString(16).padStart(64,"0")}function S(t){const e=H(v(t));if(32!==e.length)throw new Error("Error: expected 32 bytes");return e}function I(t){const e=t.toString(16);return 1&e.length?`0${e}`:e}function P(t){if("string"!=typeof t)throw new TypeError("hexToNumber: expected string, got "+typeof t);return BigInt(`0x${t}`)}function H(t){if("string"!=typeof t)throw new TypeError("hexToBytes: expected string, got "+typeof t);if(t.length%2)throw new Error("hexToBytes: received invalid unpadded hex"+t.length);const e=new Uint8Array(t.length/2);for(let n=0;n<e.length;n++){const r=2*n,i=t.slice(r,r+2),s=Number.parseInt(i,16);if(Number.isNaN(s)||s<0)throw new Error("Invalid byte sequence");e[n]=s}return e}function U(t){return P(B(t))}function Z(t){return t instanceof Uint8Array?Uint8Array.from(t):H(t)}function L(t){if("number"==typeof t&&Number.isSafeInteger(t)&&t>0)return BigInt(t);if("bigint"==typeof t&&_(t))return t;throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n")}function k(t,e=c.P){const n=t%e;return n>=s?n:e+n}function R(t,e){const{P:n}=c;let r=t;for(;e-- >s;)r*=r,r%=n;return r}function O(t,e=c.P){if(t===s||e<=s)throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);let n=k(t,e),r=e,i=s,f=o,a=o,h=s;for(;n!==s;){const t=r/n,e=r%n,s=i-a*t,o=f-h*t;r=n,n=e,i=a,f=h,a=s,h=o}if(r!==o)throw new Error("invert: does not exist");return k(i,e)}const T=(t,e)=>(t+e/f)/e,C={a1:BigInt("0x3086d221a7d46bcde86c90e49284eb15"),b1:-o*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),a2:BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),b2:BigInt("0x3086d221a7d46bcde86c90e49284eb15"),POW_2_128:BigInt("0x100000000000000000000000000000000")};function N(t){const{n:e}=c,{a1:n,b1:r,a2:i,b2:s,POW_2_128:o}=C,f=T(s*t,e),a=T(-r*t,e);let h=k(t-f*n-a*i,e),u=k(-f*r-a*s,e);const l=h>o,d=u>o;if(l&&(h=e-h),d&&(u=e-u),h>o||u>o)throw new Error("splitScalarEndo: Endomorphism failed, k="+t);return{k1neg:l,k1:h,k2neg:d,k2:u}}function z(t){const{n:e}=c,n=8*t.length-256;let r=U(t);return n>0&&(r>>=BigInt(n)),r>=e&&(r-=e),r}let F,G;class D{constructor(){this.v=new Uint8Array(32).fill(1),this.k=new Uint8Array(32).fill(0),this.counter=0}hmac(...t){return nt.hmacSha256(this.k,...t)}hmacSync(...t){return G(this.k,...t)}checkSync(){if("function"!=typeof G)throw new d("hmacSha256Sync needs to be set")}incr(){if(this.counter>=1e3)throw new Error("Tried 1,000 k values for sign(), all were invalid");this.counter+=1}async reseed(t=new Uint8Array){this.k=await this.hmac(this.v,Uint8Array.from([0]),t),this.v=await this.hmac(this.v),0!==t.length&&(this.k=await this.hmac(this.v,Uint8Array.from([1]),t),this.v=await this.hmac(this.v))}reseedSync(t=new Uint8Array){this.checkSync(),this.k=this.hmacSync(this.v,Uint8Array.from([0]),t),this.v=this.hmacSync(this.v),0!==t.length&&(this.k=this.hmacSync(this.v,Uint8Array.from([1]),t),this.v=this.hmacSync(this.v))}async generate(){return this.incr(),this.v=await this.hmac(this.v),this.v}generateSync(){return this.checkSync(),this.incr(),this.v=this.hmacSync(this.v),this.v}}function _(t){return s<t&&t<c.n}function $(t){return s<t&&t<c.P}function W(t,e,n){const r=U(t);if(!_(r))return;const{n:i}=c,f=p.BASE.multiply(r),a=k(f.x,i);if(a===s)return;const h=k(O(r,i)*k(e+n*a,i),i);if(h===s)return;const u=new x(a,h);return{sig:u,recovery:(f.x===u.r?0:2)|Number(f.y&o)}}function q(t){let e;if("bigint"==typeof t)e=t;else if("number"==typeof t&&Number.isSafeInteger(t)&&t>0)e=BigInt(t);else if("string"==typeof t){if(64!==t.length)throw new Error("Expected 32 bytes of private key");e=P(t)}else{if(!(t instanceof Uint8Array))throw new TypeError("Expected valid private key");if(32!==t.length)throw new Error("Expected 32 bytes of private key");e=U(t)}if(!_(e))throw new Error("Expected private key: 0 < key < n");return e}function V(t){if(t instanceof x)return t.assertValidity(),t;try{return x.fromDER(t)}catch(e){return x.fromCompact(t)}}function K(t,e=!1){return p.fromPrivateKey(t).toRawBytes(e)}function M(t){return U(t.length>32?t.slice(0,32):t)}function j(t){const e=M(t),n=k(e,c.n);return X(n<s?e:n)}function X(t){return S(t)}function J(t,e,n){if(null==t)throw new Error(`sign: expected valid message hash, not "${t}"`);const r=Z(t),i=q(e),s=[X(i),j(r)];if(null!=n){!0===n&&(n=nt.randomBytes(32));const t=Z(n);if(32!==t.length)throw new Error("sign: Expected 32 bytes of extra data");s.push(t)}return{seed:m(...s),m:M(r),d:i}}function Y(t,e){let{sig:n,recovery:r}=t;const{canonical:i,der:s,recovered:o}=Object.assign({canonical:!0,der:!0},e);i&&n.hasHighS()&&(n=n.normalizeS(),r^=1);const f=s?n.toDERRawBytes():n.toCompactRawBytes();return o?[f,r]:f}function Q(t,e,n={}){const{seed:r,m:i,d:s}=J(t,e,n.extraEntropy);let o;const f=new D;for(f.reseedSync(r);!(o=W(f.generateSync(),i,s));)f.reseedSync();return Y(o,n)}p.BASE._setWindowSize(8);const tt={node:r||(r=n.t(i,2)),web:"object"==typeof self&&"crypto"in self?self.crypto:void 0},et={},nt={bytesToHex:B,hexToBytes:H,concatBytes:m,mod:k,invert:O,isValidPrivateKey(t){try{return q(t),!0}catch(t){return!1}},_bigintTo32Bytes:S,_normalizePrivateKey:q,hashToPrivateKey:t=>{if((t=Z(t)).length<40||t.length>1024)throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");return S(k(U(t),c.n-o)+o)},randomBytes:(t=32)=>{if(tt.web)return tt.web.getRandomValues(new Uint8Array(t));if(tt.node){const{randomBytes:e}=tt.node;return Uint8Array.from(e(t))}throw new Error("The environment doesn't have randomBytes function")},randomPrivateKey:()=>nt.hashToPrivateKey(nt.randomBytes(40)),sha256:async(...t)=>{if(tt.web){const e=await tt.web.subtle.digest("SHA-256",m(...t));return new Uint8Array(e)}if(tt.node){const{createHash:e}=tt.node,n=e("sha256");return t.forEach((t=>n.update(t))),Uint8Array.from(n.digest())}throw new Error("The environment doesn't have sha256 function")},hmacSha256:async(t,...e)=>{if(tt.web){const n=await tt.web.subtle.importKey("raw",t,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]),r=m(...e),i=await tt.web.subtle.sign("HMAC",n,r);return new Uint8Array(i)}if(tt.node){const{createHmac:n}=tt.node,r=n("sha256",t);return e.forEach((t=>r.update(t))),Uint8Array.from(r.digest())}throw new Error("The environment doesn't have hmac-sha256 function")},sha256Sync:void 0,hmacSha256Sync:void 0,taggedHash:async(t,...e)=>{let n=et[t];if(void 0===n){const e=await nt.sha256(Uint8Array.from(t,(t=>t.charCodeAt(0))));n=m(e,e),et[t]=n}return nt.sha256(n,...e)},taggedHashSync:(t,...e)=>{if("function"!=typeof F)throw new d("sha256Sync is undefined, you need to set it");let n=et[t];if(void 0===n){const e=F(Uint8Array.from(t,(t=>t.charCodeAt(0))));n=m(e,e),et[t]=n}return F(n,...e)},precompute(t=8,e=p.BASE){const n=e===p.BASE?e:new p(e.x,e.y);return n._setWindowSize(t),n.multiply(a),n}};Object.defineProperties(nt,{sha256Sync:{configurable:!1,get:()=>F,set(t){F||(F=t)}},hmacSha256Sync:{configurable:!1,get:()=>G,set(t){G||(G=t)}}})}}]);